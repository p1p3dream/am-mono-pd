{{- $config := datasource "config" -}}
{{- $env := datasource "env" -}}

{{- $deployment := $env.ABODEMINE_TOFU_DEPLOYMENT -}}
{{- $vars := $config.vars -}}
{{- $user_data := $vars.user_data -}}

#!/bin/bash
# Code generated by gomplate. DO NOT EDIT.

set -eo pipefail

echo ">> Begin of user_data script."

################################################################################
# Locales.
################################################################################

# Locales first so if we need to ssh early we won't have encoding issues.

apt-get -y install locales
export LANG=en_US.UTF-8
echo "${LANG} UTF-8" > /etc/locale.gen

locale-gen

################################################################################
# SSHD.
################################################################################

# Ensure we can ssh into the instance for debugging.

sed -r -i \
    's/^\s*#\s*Port .*/Port {{ $vars.ssh_port }}/' \
    /etc/ssh/sshd_config

systemctl restart sshd

################################################################################
# Packages.
################################################################################

export DEBIAN_FRONTEND=noninteractive

apt-get -y update
apt-get -y upgrade
apt-get -y install \
    build-essential \
    ca-certificates \
    checkinstall \
    clang \
    clang-format \
    clang-tools \
    cmake \
    curl \
    debhelper \
    devscripts \
    dnsutils \
    fakeroot \
    gnupg \
    gnupg-agent \
    gnupg2 \
    graphviz \
    groff \
    hostname \
    hping3 \
    htop \
    iputils-ping \
    jq \
    less \
    libarchive-tools \
    libssl-dev \
    lintian \
    locales \
    lsb-release \
    lua5.1 \
    luajit2 \
    man \
    mariadb-client \
    ncurses-term \
    net-tools \
    ncal \
    nmap \
    openssh-server \
    p7zip-full \
    parted \
    pkg-config \
    pwgen \
    python{{ $user_data.python_version }} \
    python{{ $user_data.python_version }}-venv \
    python3-dotenv-cli \
    rsync \
    socat \
    software-properties-common \
    sqlite3 \
    sqlite3-tools \
    sudo \
    telnet \
    tesseract-ocr \
    tmux \
    uuid-runtime \
    vim \
    wget \
    whois \
    xz-utils \
    zlib1g-dev \
    zsh \
    zstd

echo "Adding packages for cross-compilation."
apt-get -y install \
{{- if eq $user_data.arch "amd64" }}
    g++-aarch64-linux-gnu
{{- else if eq $user_data.arch "arm64" }}
    g++-x86-64-linux-gnu
{{- end }}

echo "Setting Backports apt sources"
echo "deb http://deb.debian.org/debian $(lsb_release -cs)-backports main" \
| tee -a /etc/apt/sources.list.d/debian-backports.list

echo "Setting Docker apt sources"
curl -LSfs https://download.docker.com/linux/debian/gpg \
| apt-key --keyring /usr/share/keyrings/docker-archive-keyring.gpg add -
echo "deb [signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" \
| tee -a /etc/apt/sources.list.d/docker-ce.list

echo "Setting Google apt sources"
curl -LSfs https://packages.cloud.google.com/apt/doc/apt-key.gpg \
| apt-key --keyring /usr/share/keyrings/cloud.google.gpg add -
echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] http://packages.cloud.google.com/apt cloud-sdk main" \
| tee -a /etc/apt/sources.list.d/google-cloud-sdk.list

echo "Setting PostgreSQL apt sources"
curl -LSfs https://www.postgresql.org/media/keys/ACCC4CF8.asc \
| apt-key --keyring /usr/share/keyrings/postgresql.gpg add -
echo "deb [signed-by=/usr/share/keyrings/postgresql.gpg] http://apt.postgresql.org/pub/repos/apt/ $(lsb_release -cs)-pgdg main" \
| tee -a /etc/apt/sources.list.d/postgresql.list

apt-get -y update

# Install backports packages.
apt-get -y install -t $(lsb_release -cs)-backports \
    git \
    valkey-tools

# Install external (apt sources) packages.
apt-get -y install \
    docker-ce \
    docker-ce-cli \
    containerd.io \
    docker-buildx-plugin \
    docker-compose-plugin \
    google-cloud-sdk \
    kubectl \
    postgresql-{{ $user_data.postgresql_version }} \
    postgresql-client

apt-get -y autoclean autoremove

# Uncomment to remove apt lists.
# rm -rf /var/lib/apt/lists/*

################################################################################
# Groups and users.
################################################################################

groupadd --gid {{ $user_data.user.gid }} {{ $user_data.user.group }}
useradd \
    --shell /usr/bin/zsh \
    --gid {{ $user_data.user.gid }} \
    --uid {{ $user_data.user.uid }} \
    --groups {{ $user_data.docker.group }} \
    --create-home \
    {{ $user_data.user.user }}

################################################################################
# Block devices: persistent.
################################################################################

DEVICE={{ $vars.block_devices.persistent.device_name }}
PARTITION=${DEVICE}1

if [ ! -b ${PARTITION} ]; then
    echo "Partitioning ${PARTITION}..."
    parted ${DEVICE} --script mklabel gpt mkpart primary ext4 1MiB 100%
    partprobe ${DEVICE}
    sync
else
    echo "Partition ${PARTITION} already exists."

    if growpart -N ${DEVICE} 1; then
        echo "Partition ${PARTITION} can be resized. Applying changes now."

        growpart --update auto ${DEVICE} 1
        e2fsck -f ${PARTITION}
        resize2fs ${PARTITION}
    fi
fi

printf "Waiting for device to be ready..."
while ! test -b ${PARTITION}; do
    printf "."
    sleep 1
done
echo "OK"

FSTYPE=$(lsblk -f ${PARTITION} -no FSTYPE)

if [ "${FSTYPE}" != "ext4" ]; then
    echo "Creating filesystem on ${PARTITION}..."
    mkfs.ext4 -E lazy_itable_init=0,lazy_journal_init=0 -m 0 -T default -O sparse_super2 ${PARTITION}
else
    echo "Filesystem ${PARTITION} already exists."
fi

PARTITION_UUID=$(blkid --output export ${PARTITION} | sed -r -n '/^UUID=/ s/UUID=// p')

echo "UUID=${PARTITION_UUID} {{ $vars.block_devices.persistent.mount_point }} ext4 defaults,noatime,nodiratime,discard 0 2" \
>> /etc/fstab

mkdir {{ $vars.block_devices.persistent.mount_point }}

# Use mount without the device to ensure fstab is correct.
mount {{ $vars.block_devices.persistent.mount_point }}

################################################################################
# Postgresql.
################################################################################

POSTGRESQL_HOST_DIR=/var/lib/postgresql
POSTGRESQL_HOST_VERSION_DIR=${POSTGRESQL_HOST_DIR}/{{ $user_data.postgresql_version }}
POSTGRESQL_MNT_DIR={{ $vars.block_devices.persistent.mount_point }}/var/lib/postgresql
POSTGRESQL_MNT_VERSION_DIR=${POSTGRESQL_MNT_DIR}/{{ $user_data.postgresql_version }}

mkdir -p ${POSTGRESQL_MNT_DIR}
chown postgres:postgres ${POSTGRESQL_MNT_DIR}

echo "Configuring PostgreSQL to use persistent storage."
systemctl stop postgresql

if [ -d ${POSTGRESQL_MNT_VERSION_DIR} ]; then
    echo "PostgreSQL data already exists in persistent storage."
else
    echo "Moving PostgreSQL data to persistent storage."
    mkdir -p ${POSTGRESQL_MNT_VERSION_DIR}
    rsync -a --exclude='*.pid' ${POSTGRESQL_HOST_VERSION_DIR}/ ${POSTGRESQL_MNT_VERSION_DIR}/
fi

rm -rf ${POSTGRESQL_HOST_DIR}
ln -s ${POSTGRESQL_MNT_DIR} ${POSTGRESQL_HOST_DIR}
systemctl start postgresql

################################################################################
# Docker.
################################################################################

PERSISTENT_VAR_LIB_DIR="{{ filepath.Join $vars.block_devices.persistent.mount_point "var/lib" }}"
PERSISTENT_DOCKER_DIR="{{ filepath.Join $vars.block_devices.persistent.mount_point "var/lib/docker" }}"

echo "Configuring Docker to use persistent storage."
systemctl stop docker.socket
systemctl stop docker.service

if [ -d ${PERSISTENT_DOCKER_DIR} ]; then
    echo "Docker data already exists in persistent storage."
    rm -rf /var/lib/docker
else
    echo "Moving Docker data to persistent storage."
    mkdir -p ${PERSISTENT_VAR_LIB_DIR}
    mv /var/lib/docker ${PERSISTENT_DOCKER_DIR}
fi

ln -s ${PERSISTENT_DOCKER_DIR} /var/lib/docker
systemctl start docker

PERSISTENT_WORKS_DIR="{{ filepath.Join $vars.block_devices.persistent.mount_point "works" }}"

# Works.
echo "Setting up works directory."
mkdir -p ${PERSISTENT_WORKS_DIR}
ln -s ${PERSISTENT_WORKS_DIR} {{ $user_data.dirs.works }}
# Ensure ownership of the works directory.
chown {{ $user_data.user.user }}:{{ $user_data.user.group }} ${PERSISTENT_WORKS_DIR}

################################################################################
# Packer.
################################################################################

mkdir -p \
    {{ filepath.Join $user_data.dirs.opt "pkg" }} \
    {{ filepath.Join $user_data.dirs.tmp "bin" }} \
    {{ filepath.Join $user_data.dirs.tmp "downloads" }} \
    {{ filepath.Join $user_data.dirs.tmp "etc" }}

PACKER_ARCH="{{ if eq $user_data.arch "amd64" }}x86_64{{ else if eq $user_data.arch "arm64" }}aarch64{{ end }}"
PACKER_PATH=packer/v{{ $user_data.packer.version }}/packer-{{ $user_data.packer.version }}-${PACKER_ARCH}-unknown-linux-gnu.tar.zst

aws s3 cp \
    s3://{{ index $config.deployment_vars.buckets "secure-download" }}/${PACKER_PATH} \
    {{ filepath.Join $user_data.dirs.tmp "downloads/packer.tar.zst" }}

zstd -cd -T0 {{ filepath.Join $user_data.dirs.tmp "downloads/packer.tar.zst" }} \
| bsdtar -C {{ filepath.Join $user_data.dirs.tmp "bin" }} -xf -

aws s3 cp \
    s3://{{ index $config.deployment_vars.buckets "secure-download" }}/packer/config.yaml.zst \
    {{ filepath.Join $user_data.dirs.tmp "downloads/config.yaml.zst" }}

zstd \
    -o {{ filepath.Join $user_data.dirs.tmp "etc/config.yaml" }} \
    -df {{ filepath.Join $user_data.dirs.tmp "downloads/config.yaml.zst" }}

chown -R {{ $user_data.user.user }}:{{ $user_data.user.group }} \
    {{ $user_data.dirs.opt }} \
    {{ $user_data.dirs.tmp }}

su {{ $user_data.user.user }} -c " \
{{ filepath.Join $user_data.dirs.tmp "bin/packer" }} \
    --tracing-level info \
    --config {{ filepath.Join $user_data.dirs.tmp "etc/config.yaml" }} \
    --downloads-dir {{ filepath.Join $user_data.dirs.tmp "downloads" }} \
    --target {{ $user_data.packer.target }} \
    --packages-dir {{ filepath.Join $user_data.dirs.opt "pkg" }} \
    --temp-dir {{ filepath.Join $user_data.dirs.tmp }} \
    --seven-zip 7za \
    --profiles {{ $user_data.packer.profiles }} \
"

rm -rf {{ filepath.Join "/home" $user_data.user.user ".cache/gobuild" }}
rm -rf {{ filepath.Join "/home" $user_data.user.user "go" }}

################################################################################
# Files: home.tar.zst.
################################################################################

aws s3 cp s3://{{ index $config.deployment_vars.buckets "mono-build" }}/{{ $env.ABODEMINE_BUILD_ID }}/home.tar.zst {{ filepath.Join $user_data.dirs.tmp "downloads/home.tar.zst" }}

su {{ $user_data.user.user }} -c " \
zstd -cd -T0 {{ filepath.Join $user_data.dirs.tmp "downloads/home.tar.zst" }} \
| bsdtar -C {{ filepath.Join "/home" $user_data.user.user }} -xf - \
"

################################################################################
# Files: etc.tar.zst.
################################################################################

aws s3 cp s3://{{ index $config.deployment_vars.buckets "mono-build" }}/{{ $env.ABODEMINE_BUILD_ID }}/etc.tar.zst {{ filepath.Join $user_data.dirs.tmp "downloads/etc.tar.zst" }}

zstd -cd -T0 {{ filepath.Join $user_data.dirs.tmp "downloads/etc.tar.zst" }} \
| bsdtar -C /etc --no-same-owner -xf -

systemctl enable --now abodemine-init.service
# systemctl enable actions-runner.service

################################################################################
# Cleanup.
################################################################################

rm -rf {{ $user_data.dirs.tmp }}

echo ">> End of user_data script."
