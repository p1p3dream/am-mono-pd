{{- $config := datasource "config" -}}
{{- $vars := $config.vars -}}

# Code generated by gomplate. DO NOT EDIT.

# General functions.

function append_path() {
    local p=("${(@s/:/)PATH}")

    if (( ! $p[(Ie)$1] )); then
        export PATH="${PATH}:$1"
    fi
}

function prepend_path() {
    local p=("${(@s/:/)PATH}")

    if (( ! $p[(Ie)$1] )); then
        export PATH="$1:${PATH}"
    fi
}

# Autoload.

autoload -U colors && colors
autoload -Uz up-line-or-beginning-search
autoload -Uz down-line-or-beginning-search

bindkey -e

# Options.
# https://zsh.sourceforge.io/Doc/Release/Options.html

unsetopt \
    autocd \
    beep

setopt EXTENDED_HISTORY     # Save each command’s beginning timestamp (in seconds since the epoch) and the duration (in seconds) to the history file.
setopt HIST_FIND_NO_DUPS    # When searching for history entries in the line editor, do not display duplicates of a line previously found, even if the duplicates are not contiguous.
setopt HIST_IGNORE_ALL_DUPS # If a new command line being added to the history list duplicates an older one, the older command is removed from the list (even if it is not the previous event).
setopt HIST_IGNORE_DUPS     # Do not enter command lines into the history list if they are duplicates of the previous event.
setopt HIST_IGNORE_SPACE    # Remove command lines from the history list when the first character on the line is a space, or when one of the expanded aliases contains a leading space.
setopt HIST_VERIFY          # Whenever the user enters a line with history expansion, don’t execute the line directly; instead, perform history expansion and reload the line into the editing buffer.
setopt PROMPT_SUBST         # If set, parameter expansion, command substitution and arithmetic expansion are performed in prompts.
setopt SHARE_HISTORY        # This option both imports new commands from the history file, and also causes your typed commands to be appended to the history file (the latter is like specifying INC_APPEND_HISTORY, which should be turned off if this option is in effect).

ZLE_REMOVE_SUFFIX_CHARS=""

# History.

HISTFILESIZE=60000
HISTSIZE=60000
SAVEHIST=60000

# create a zkbd compatible hash;
# to add other keys to this hash, see: man 5 terminfo
typeset -g -A key

key[Home]="${terminfo[khome]}"
key[End]="${terminfo[kend]}"
key[Insert]="${terminfo[kich1]}"
key[Backspace]="${terminfo[kbs]}"
key[Delete]="${terminfo[kdch1]}"
key[Up]="${terminfo[kcuu1]}"
key[Down]="${terminfo[kcud1]}"
key[Left]="${terminfo[kcub1]}"
key[Right]="${terminfo[kcuf1]}"
key[PageUp]="${terminfo[kpp]}"
key[PageDown]="${terminfo[knp]}"
key[Shift-Tab]="${terminfo[kcbt]}"

zle -N up-line-or-beginning-search
zle -N down-line-or-beginning-search

# setup key accordingly
[[ -n "${key[Home]}"      ]] && bindkey -- "${key[Home]}"       beginning-of-line
[[ -n "${key[End]}"       ]] && bindkey -- "${key[End]}"        end-of-line
[[ -n "${key[Insert]}"    ]] && bindkey -- "${key[Insert]}"     overwrite-mode
[[ -n "${key[Backspace]}" ]] && bindkey -- "${key[Backspace]}"  backward-delete-char
[[ -n "${key[Delete]}"    ]] && bindkey -- "${key[Delete]}"     delete-char
[[ -n "${key[Up]}"        ]] && bindkey -- "${key[Up]}"         up-line-or-beginning-search
[[ -n "${key[Down]}"      ]] && bindkey -- "${key[Down]}"       down-line-or-beginning-search
[[ -n "${key[Left]}"      ]] && bindkey -- "${key[Left]}"       backward-char
[[ -n "${key[Right]}"     ]] && bindkey -- "${key[Right]}"      forward-char
[[ -n "${key[PageUp]}"    ]] && bindkey -- "${key[PageUp]}"     beginning-of-buffer-or-history
[[ -n "${key[PageDown]}"  ]] && bindkey -- "${key[PageDown]}"   end-of-buffer-or-history
[[ -n "${key[Shift-Tab]}" ]] && bindkey -- "${key[Shift-Tab]}"  reverse-menu-complete

# Finally, make sure the terminal is in application mode, when zle is
# active. Only then are the values from $terminfo valid.
if (( ${+terminfo[smkx]} && ${+terminfo[rmkx]} )); then
    autoload -Uz add-zle-hook-widget
    function zle_application_mode_start { echoti smkx }
    function zle_application_mode_stop { echoti rmkx }
    add-zle-hook-widget -Uz zle-line-init zle_application_mode_start
    add-zle-hook-widget -Uz zle-line-finish zle_application_mode_stop
fi

# Zstyle.

zstyle :compinstall filename "~/.zshrc"
zstyle ':completion:*' rehash true

# Prompt.

if [ "${TERM}" = "xterm" ]; then
    export TERM=xterm-256color
fi

# for code in {000..255}; do print -P -- "$code: %F{$code}Color%f"; done

# Single quotes so variables are not expanded.
local promptDate='$(date +"%Y-%m-%d %H:%M:%S")'

PS1="%F{240}[%?] ${promptDate} %n@%m:%3d%f
%F{072}$%f "

# Default aliases.

alias egrep="egrep --color=auto"
alias fgrep="fgrep --color=auto"
alias grep="grep --color=auto"

alias d='docker ps -a'

alias g="git s"

alias ls="ls --color=auto"
alias ll="ls -lah"
alias lr="ls -lahrt"

alias tmux="tmux -2"

# Exports.
export ABODEMINE_CACHE={{ $vars.dirs.cache }}
export ABODEMINE_NAMESPACE={{ $vars.namespace }}
export ABODEMINE_OPT={{ $vars.dirs.opt }}
export ABODEMINE_SHELL=true
export ABODEMINE_SRC={{ $vars.dirs.src }}
export ABODEMINE_TMP={{ $vars.dirs.tmp }}
export ABODEMINE_WORKSPACE={{ $vars.dirs.workspace }}

# Order matters.
export LANG=en_US.UTF-8
export LANGUAGE=${LANG}
export LC_ALL=${LANG}

export COREPACK_ENABLE_DOWNLOAD_PROMPT=0
export EDITOR="${VISUAL}"
export GPG_TTY=$(tty)
export VISUAL="vim"
export WORKS_DIR={{ $vars.dirs.works }}
export YARN_CACHE_FOLDER={{ filepath.Join $vars.dirs.works "home/.cache/yarn" }}

if [ ! -d "{{ filepath.Join $vars.dirs.works "home" }}" ]; then
    mkdir -p "{{ filepath.Join $vars.dirs.works "home" }}"
fi

HISTFILE={{ filepath.Join $vars.dirs.works "home/.zsh_history" }}

# Update PATH.
function () {
    # This path should be used to experimental work
    # and must not conflict with existing binaries.
    prepend_path "${HOME}/.local/bin"

    # Known paths.
    local paths=(
        "{{ filepath.Join $vars.dirs.works "bin" }}"
    )

    for (( i=1; i<=${#paths[@]}; i++ )); do
        if [ -d "${paths[i]}" ]; then
            append_path "${paths[i]}"
        fi
    done

    # Package paths.
    paths=(${(s/:/)$(cat {{ filepath.Join $vars.dirs.opt "pkg/PATH" }} | envsubst)})

    for (( i=${#paths[@]}; i>0; i-- )); do
        prepend_path "${paths[i]}"
    done

    # Env paths.

    if [ -n "${PATH_APPEND}" ]; then
        paths=(${(s/:/)PATH_APPEND})

        for (( i=1; i<=${#paths[@]}; i++ )); do
            append_path "${paths[i]}"
        done
    fi

    if [ -n "${PATH_PREPEND}" ]; then
        paths=(${(s/:/)PATH_PREPEND})

        for (( i=${#paths[@]}; i>0; i-- )); do
            prepend_path "${paths[i]}"
        done
    fi
}

# Must be loaded AFTER changing $fpath.
autoload -Uz compinit && compinit

################################################################################
# fzf
################################################################################

source <(fzf --zsh)

# Use fd (https://github.com/sharkdp/fd) for listing path candidates.
# - The first argument to the function ($1) is the base path to start traversal
# - See the source code (completion.{bash,zsh}) for the details.
_fzf_compgen_path() {
    fd --hidden --follow --exclude ".git" . "$1"
}

# Use fd to generate the list for directory completion
_fzf_compgen_dir() {
    fd --type d --hidden --follow --exclude ".git" . "$1"
}

# Setting fd as the default source for fzf
export FZF_DEFAULT_COMMAND='fd --type f --strip-cwd-prefix --hidden --follow --exclude .git'

# Show full command in preview window.
export FZF_CTRL_R_OPTS="\
    --preview 'echo {}' --preview-window border-bottom:down:wrap\
    --bind 'ctrl-_:toggle-preview'\
"

export FZF_CTRL_T_COMMAND="${FZF_DEFAULT_COMMAND}"

# Preview file content using bat (https://github.com/sharkdp/bat)
export FZF_CTRL_T_OPTS="\
    --preview '{{ filepath.Join $vars.dirs.opt "pkg/bat/bat" }} -n --color=always {}'\
    --preview-window=hidden\
    --bind 'ctrl-_:toggle-preview'\
"

function rg-fzf() {
    RG_PREFIX="{{ filepath.Join $vars.dirs.opt "pkg/ripgrep/rg" }} --hidden --column --line-number --no-heading --color=always --smart-case "
    INITIAL_QUERY="${*:-}"
    : | fzf --ansi --disabled --query "${INITIAL_QUERY}" \
        --bind "start:reload:${RG_PREFIX} {q}" \
        --bind "change:reload:sleep 0.1; ${RG_PREFIX} {q} || true" \
        --delimiter : \
        --preview '{{ filepath.Join $vars.dirs.opt "pkg/bat/bat" }} --color=always {1} --highlight-line {2}' \
        --preview-window 'up,60%,border-bottom,+{2}+3/3,~3' \
        --bind 'enter:become(code -g {1}:{2})'
}

zle -N rg-fzf
bindkey -M emacs '^F' rg-fzf
bindkey -M vicmd '^F' rg-fzf
bindkey -M viins '^F' rg-fzf

################################################################################
# tmux
################################################################################

# Tmux Attach.
function ta() {
    sessionName="$1"

    if tmux list-sessions -F "#{session_name}" 2> /dev/null | grep -q "$sessionName"; then
        tmux attach-session -d -t "$sessionName"
    else
        tmux new-session -s "$sessionName"
    fi
}

function _ta_completions() {
    _arguments \
        '1: :->firstarg' \
        '*::arg:->default'

    case $state in
        firstarg)
            local -a options
            options=($(tmux list-sessions -F "#{session_name}" 2> /dev/null))
            _describe "options" options
            ;;
        default)
            # No completions.
            ;;
    esac
}

compdef _ta_completions ta

# Tmux Detach.
function td() {
    tmux detach
}

################################################################################
# gpg
################################################################################

# Use gpg for ssh.
if pgrep gpg-agent 2>&1 > /dev/null; then
    unset SSH_AGENT_PID
    export SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)"
    gpg-connect-agent updatestartuptty /bye >/dev/null
fi

if [ -f "${HOME}/.local/.zshrc" ]; then
    source "${HOME}/.local/.zshrc"
fi
